# MovieLens_Analytics

Проект по разработке аналитического модуля на Python для исследования датасета MovieLens и подготовке отчета в Jupyter Notebook с использованием исключительно собственных классов и методов.

В рамках проекта реализован модуль `movielens_analysis.py`, включающий классы для работы с файлами `movies.csv`, `ratings.csv`, `tags.csv`, `links.csv`, а также набор автотестов на PyTest для каждого метода.

---

## Описание проекта

Цель проекта — построить воспроизводимый аналитический пайплайн на основе объектно-ориентированного подхода:

- структурировать данные MovieLens через собственные классы  
- реализовать набор методов для анализа фильмов, оценок, тегов и ссылок  
- обеспечить надежность расчетов и стабильность форматов вывода через автотесты  
- подготовить аналитический отчет в Jupyter Notebook, используя исключительно модуль `movielens_analysis.py`  

Проект ориентирован на демонстрацию навыков построения аналитического инструмента, а не просто разового анализа данных.

---

## Данные

Используется датасет `ml-latest-small` (MovieLens). Основные файлы:

- `movies.csv` — список фильмов и жанров  
- `ratings.csv` — оценки пользователей и временные метки  
- `tags.csv` — пользовательские теги и временные метки  
- `links.csv` — связи с внешними базами (IMDb / TMDb)  

Для ускорения обработки применяется ограничение по размеру выборки (например, первые 1000 строк).

---

## Архитектура решения

Ядро проекта — модуль `movielens_analysis.py`, внутри которого реализованы классы:

- **Movies** — парсинг фильмов, распределения по годам и жанрам, топы по жанрам  
- **Ratings** — распределения по оценкам и годам, топы по количеству оценок, средние/медианные оценки, анализ вариативности  
- **Tags** — анализ текстовых тегов (длина, количество слов, популярность), поиск по подстроке, распределения по времени  
- **Links** — сопоставление идентификаторов и обогащение данных через IMDb (получение бюджета, сборов, режиссера и продолжительности)

Дополнительно реализован файл `test_all.py` с набором автотестов, покрывающим каждый метод.

---

## Что было сделано

### 1. Реализация собственного аналитического модуля

- Разработаны классы для загрузки и преобразования каждого источника данных  
- Вся логика обработки и расчетов вынесена в модуль  
- Методы возвращают унифицированные структуры (dict/list/tuple), пригодные для дальнейшей аналитики  
- Реализованы внутренние представления (например, логика Movies и Users внутри Ratings) для анализа на разных уровнях  

---

### 2. Аналитика по movies.csv

- Получение полного списка фильмов (ID, название, год, список жанров)  
- Распределение фильмов по годам выпуска  
- Распределение по жанрам  
- Поиск фильмов с максимальным количеством жанров  

---

### 3. Аналитика по ratings.csv

- Распределение оценок по годам (по timestamp)  
- Распределение по значениям рейтинга  
- Топ фильмов по количеству оценок  
- Топ фильмов по средней и медианной оценке  
- Выявление “противоречивых” фильмов через дисперсию оценок  
- Анализ активности пользователей по количеству оценок и вариативности оценивания  

---

### 4. Аналитика по tags.csv

- Теги с максимальным количеством слов  
- Самые длинные теги по количеству символов  
- Пересечение длинных и многословных тегов  
- Самые популярные теги по частоте  
- Поиск тегов по подстроке  
- Распределение тегов по годам и месяцам (по timestamp)  

---

### 5. Обогащение данных через links.csv и IMDb

- Построение сопоставления `movieId → imdbId`  
- Реализация логики запроса IMDb-страниц и извлечения атрибутов:  
  - режиссер  
  - бюджет  
  - мировые сборы  
  - продолжительность  
- Расчет производных метрик:  
  - прибыльность (сборы минус бюджет)  
  - стоимость минуты фильма  

---

### 6. Автотестирование

Для каждого метода реализованы тесты, проверяющие:

- корректность типа возвращаемых данных  
- корректность типов элементов внутри структур  
- корректность сортировки результатов  
- корректное поведение при некорректных входных данных  

Тестирование позволяет гарантировать стабильность аналитического API.

---

## Основные сложности и решения

### 1. Проектирование классов и их взаимодействие

Проблема:  
Необходимо было спроектировать классы таким образом, чтобы:

- каждый класс отвечал только за свою область данных  
- при этом обеспечивалась возможность перекрестной аналитики (например, рейтинги в разрезе фильмов и пользователей)  
- не нарушалась логика задания (отчет должен использовать только модуль)

Решение:

- Четко разделена ответственность классов (Single Responsibility)  
- Реализованы вложенные представления (например, Movies и Users внутри Ratings)  
- Исключена дублирующая логика — общие операции вынесены в методы классов  
- Все вычисления централизованы в модуле, ноутбук выполняет только вызовы методов  

---

### 2. Парсинг movies.csv (сложные названия фильмов)

Проблема:  
Названия фильмов содержат запятые и кавычки, что делает стандартное разбиение строки по запятой некорректным и приводит к смещению столбцов.

Решение:

- Реализован безопасный парсер строк (smart split), корректно обрабатывающий случаи с кавычками  
- Логика обработки полностью вынесена внутрь класса Movies  

---

### 3. Ограничения и нестабильность IMDb-скрейпинга

Проблема:

- Запросы к IMDb выполняются медленно  
- Большое количество запросов увеличивает время выполнения  
- Возможны сетевые ошибки  

Решение:

- Введено ограничение на количество фильмов в одном вызове `get_imdb()`  
- Добавлена обработка HTTP-ошибок  
- Тестами зафиксировано корректное поведение при превышении лимита  

---

### 4. Разнородность типов данных

Проблема:

- CSV-файлы содержат строки, требующие преобразования в числовые типы  
- Timestamp необходимо преобразовывать для временной аналитики  
- Расчеты средней, медианы и дисперсии требуют корректной типизации  

Решение:

- Внутри классов реализована нормализация типов (int/float)  
- Методы возвращают предсказуемые структуры данных  
- Тестами закреплена корректность типов  

---

### 5. Стабильность сортировки результатов

Проблема:

- Топы и распределения должны быть предсказуемыми и повторяемыми  
- Без явной сортировки результаты могли отличаться  

Решение:

- Реализована явная сортировка по значениям (и при необходимости по ключам)  
- Тестами закреплена корректность порядка  

---

### 6. Ограничения задания: отчет использует только модуль

Проблема:

- В ноутбуке запрещены дополнительные импорты и вспомогательные функции  
- Вся логика должна быть реализована внутри модуля  

Решение:

- Все расчеты и вспомогательные функции вынесены в `movielens_analysis.py`  
- Ноутбук используется только как инструмент визуализации и интерпретации результатов  

---

## Технологии

- Python 3  
- Объектно-ориентированное программирование  
- PyTest (unit-тестирование)  
- requests и BeautifulSoup (веб-скрейпинг IMDb)  
- Jupyter Notebook  

---

## Как запустить

### Установка зависимостей
```bash
pip install -r requirements.txt
```

### Запуск тестов

```bash
cd src
pytest
```

###  Запуск отчета

Открыть файл `movielens_report.ipynb` в Jupyter Notebook или VS Code и выполнить ячейки.
Весь анализ выполняется исключительно через модуль `movielens_analysis.py`.

#### Результат

- Реализован аналитический модуль с четкой архитектурой и разделением ответственности
- Реализован набор автотестов, фиксирующий корректность логики, типов данных и сортировки
- Подготовлен Jupyter-отчет с последовательным анализом данных MovieLens
- Продемонстрированы навыки проектирования классов, обработки данных, тестирования и построения воспроизводимого аналитического инструмента

